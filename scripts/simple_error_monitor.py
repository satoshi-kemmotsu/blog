#!/usr/bin/env python3
"""
シンプルエラー検出・アラートシステム
自動修正なし、通知特化版

Author: Claude Code  
Date: 2025-08-10
"""

from flask import Flask, request, jsonify
import json
import logging
import requests
import os
from datetime import datetime
from pathlib import Path

# ログ設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/Users/skem/Himawari/SEO_AUTO_BLOG_PROJECT/logs/simple_error_monitor.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

app = Flask(__name__)

# 設定
PROJECT_NAME = os.getenv('PROJECT_NAME', 'ブログシステム')
SLACK_WEBHOOK_URL = os.getenv('SLACK_WEBHOOK_URL', '')  # オプション
DISCORD_WEBHOOK_URL = os.getenv('DISCORD_WEBHOOK_URL', '')  # オプション

class SimpleErrorAnalyzer:
    """シンプルなエラー検出・分析"""
    
    def __init__(self):
        self.common_error_patterns = {
            'ruby_gems': [
                'cannot load such file --',
                'LoadError',
                'Bundler::GemNotFound',
                'Could not find gem'
            ],
            'jekyll': [
                'Liquid syntax error',
                'YAML front matter',
                'Layout does not exist',
                'jekyll build failed'
            ],
            'netlify': [
                'dependency_installation script returned non-zero exit code',
                'Build script returned non-zero exit code',
                'Command failed with exit code'
            ]
        }
    
    def analyze_error(self, error_message, platform="unknown"):
        """エラー分析（修正提案なし）"""
        detected_issues = []
        
        error_lower = error_message.lower()
        
        for category, patterns in self.common_error_patterns.items():
            for pattern in patterns:
                if pattern.lower() in error_lower:
                    detected_issues.append({
                        'category': category,
                        'pattern': pattern,
                        'severity': self._get_severity(category),
                        'platform': platform
                    })
        
        return detected_issues
    
    def _get_severity(self, category):
        """エラーの深刻度判定"""
        severity_map = {
            'ruby_gems': 'HIGH',    # ビルド完全停止
            'jekyll': 'MEDIUM',     # 一部記事影響
            'netlify': 'HIGH'       # デプロイ失敗
        }
        return severity_map.get(category, 'MEDIUM')

def send_alert(error_data):
    """アラート送信（複数チャンネル）"""
    
    alert_message = format_alert_message(error_data)
    
    # コンソール出力（必須）
    logger.error("🚨 BUILD ERROR DETECTED 🚨")
    logger.error(alert_message)
    
    # ファイルログ（必須）
    log_detailed_error(error_data)
    
    # Slack通知（オプション）
    if SLACK_WEBHOOK_URL:
        send_slack_alert(alert_message)
    
    # Discord通知（オプション）
    if DISCORD_WEBHOOK_URL:
        send_discord_alert(alert_message)
    
    # システム通知（macOS）
    send_system_notification(alert_message)

def format_alert_message(error_data):
    """アラートメッセージ整形"""
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    platform = error_data.get('platform', 'Unknown')
    site_name = error_data.get('site_name', 'Unknown Site')
    error_message = error_data.get('error_message', 'No details')
    admin_url = error_data.get('admin_url', 'N/A')
    
    detected_issues = error_data.get('detected_issues', [])
    
    message = f"""
🚨 {PROJECT_NAME} - BUILD ERROR ALERT

⏰ Time: {timestamp}
🌐 Platform: {platform}
🏠 Site: {site_name}
🔗 Admin URL: {admin_url}

📋 Error Details:
{error_message}

🔍 Detected Issues ({len(detected_issues)}):
"""
    
    for i, issue in enumerate(detected_issues, 1):
        severity_emoji = "🔴" if issue['severity'] == 'HIGH' else "🟡"
        message += f"{i}. {severity_emoji} {issue['category'].upper()}: {issue['pattern']}\n"
    
    message += f"""
💡 Next Steps:
1. Check the admin panel: {admin_url}
2. Review recent commits for potential issues
3. Run Claude Code for automated diagnosis
4. Check _posts/ for malformed articles

--- Generated by Simple Error Monitor ---
"""
    
    return message.strip()

def log_detailed_error(error_data):
    """詳細エラーログ出力"""
    timestamp = datetime.now().isoformat()
    
    log_entry = {
        'timestamp': timestamp,
        'project': PROJECT_NAME,
        'platform': error_data.get('platform'),
        'site_name': error_data.get('site_name'),
        'error_message': error_data.get('error_message'),
        'admin_url': error_data.get('admin_url'),
        'detected_issues': error_data.get('detected_issues', []),
        'raw_payload': error_data.get('raw_payload')
    }
    
    # JSON形式でログファイルに記録
    log_file = Path('/Users/skem/Himawari/SEO_AUTO_BLOG_PROJECT/logs/detailed_errors.json')
    
    try:
        if log_file.exists():
            with open(log_file, 'r', encoding='utf-8') as f:
                logs = json.load(f)
        else:
            logs = []
        
        logs.append(log_entry)
        
        # 最新100件のみ保持
        if len(logs) > 100:
            logs = logs[-100:]
        
        with open(log_file, 'w', encoding='utf-8') as f:
            json.dump(logs, f, indent=2, ensure_ascii=False)
            
    except Exception as e:
        logger.error(f"詳細ログ記録エラー: {e}")

def send_slack_alert(message):
    """Slack通知"""
    try:
        payload = {
            "text": message,
            "username": "Error Monitor Bot",
            "icon_emoji": ":warning:"
        }
        
        response = requests.post(SLACK_WEBHOOK_URL, json=payload, timeout=10)
        
        if response.status_code == 200:
            logger.info("✅ Slack通知送信成功")
        else:
            logger.warning(f"⚠️ Slack通知失敗: {response.status_code}")
            
    except Exception as e:
        logger.error(f"Slack通知エラー: {e}")

def send_discord_alert(message):
    """Discord通知"""
    try:
        payload = {
            "content": message,
            "username": "Error Monitor"
        }
        
        response = requests.post(DISCORD_WEBHOOK_URL, json=payload, timeout=10)
        
        if response.status_code in [200, 204]:
            logger.info("✅ Discord通知送信成功")
        else:
            logger.warning(f"⚠️ Discord通知失敗: {response.status_code}")
            
    except Exception as e:
        logger.error(f"Discord通知エラー: {e}")

def send_system_notification(message):
    """システム通知（macOS）"""
    try:
        # macOS通知
        os.system(f'''osascript -e 'display notification "{PROJECT_NAME}でエラー発生" with title "Build Error Alert"' ''')
        logger.info("✅ システム通知送信")
        
    except Exception as e:
        logger.error(f"システム通知エラー: {e}")

@app.route('/health')
def health_check():
    """ヘルスチェック"""
    return jsonify({
        "status": "healthy", 
        "timestamp": datetime.now().isoformat(),
        "project": PROJECT_NAME,
        "mode": "ERROR_DETECTION_ONLY"
    })

@app.route('/netlify-webhook', methods=['POST'])
def netlify_webhook():
    """Netlify Webhookエンドポイント（検出専用）"""
    try:
        payload = request.json
        
        # エラー状態のみ処理
        if payload.get('state') == 'error':
            
            analyzer = SimpleErrorAnalyzer()
            
            error_data = {
                'platform': 'Netlify',
                'site_name': payload.get('name', 'Unknown'),
                'error_message': payload.get('error_message', 'No error message'),
                'admin_url': payload.get('admin_url', 'N/A'),
                'detected_issues': analyzer.analyze_error(
                    payload.get('error_message', ''), 
                    'netlify'
                ),
                'raw_payload': payload
            }
            
            # アラート送信
            send_alert(error_data)
        
        # 成功時は静かにログ
        elif payload.get('state') == 'ready':
            logger.info(f"✅ Netlify Deploy成功: {payload.get('name')}")
        
        return jsonify({"status": "processed", "mode": "detection_only"}), 200
        
    except Exception as e:
        logger.error(f"Netlify Webhookエラー: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/github-webhook', methods=['POST'])  
def github_webhook():
    """GitHub Webhookエンドポイント（検出専用）"""
    try:
        payload = request.json
        event_type = request.headers.get('X-GitHub-Event')
        
        logger.info(f"GitHub Event: {event_type}")
        
        # Workflow失敗のみ処理
        if event_type == 'workflow_run' and payload['action'] == 'completed':
            if payload['workflow_run']['conclusion'] == 'failure':
                
                analyzer = SimpleErrorAnalyzer()
                
                error_data = {
                    'platform': 'GitHub Actions',
                    'site_name': payload['repository']['full_name'],
                    'error_message': f"Workflow '{payload['workflow_run']['name']}' failed",
                    'admin_url': payload['workflow_run']['html_url'],
                    'detected_issues': analyzer.analyze_error('workflow failure', 'github'),
                    'raw_payload': payload
                }
                
                # アラート送信
                send_alert(error_data)
        
        return jsonify({"status": "processed", "mode": "detection_only"}), 200
        
    except Exception as e:
        logger.error(f"GitHub Webhookエラー: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/manual-test', methods=['POST'])
def manual_test():
    """手動テスト用エンドポイント"""
    try:
        test_data = request.json or {}
        
        analyzer = SimpleErrorAnalyzer()
        
        error_data = {
            'platform': 'Manual Test',
            'site_name': test_data.get('site', 'Test Site'),
            'error_message': test_data.get('error', 'Manual test error'),
            'admin_url': 'N/A',
            'detected_issues': analyzer.analyze_error(
                test_data.get('error', ''), 
                'manual'
            ),
            'raw_payload': test_data
        }
        
        send_alert(error_data)
        
        return jsonify({
            "status": "test_completed",
            "detected_issues": len(error_data['detected_issues'])
        }), 200
        
    except Exception as e:
        logger.error(f"手動テストエラー: {e}")
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    logger.info("🚀 Simple Error Monitor起動")
    logger.info(f"📋 Project: {PROJECT_NAME}")
    logger.info("🎯 Mode: ERROR DETECTION & ALERT ONLY")
    logger.info("❌ Auto-fix: DISABLED")
    
    # ポート8084で起動（競合回避）
    app.run(host='0.0.0.0', port=8084, debug=True)